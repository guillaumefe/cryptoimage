<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CryptoImage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(
        circle at center,
        #660000 0%,
        #1F1F1F 50%,
        #3F3F3F 100%
      );
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 10px;
      color: #333;
    }
    h2 {
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }
    .container {
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.1);
      max-width: 500px;
      width: 100%;
      text-align: center;
    }
    input[type="file"] {
      margin: 10px 0;
      padding: 10px;
      width: calc(100% - 24px);
      border-radius: 8px;
      border: 1px solid #ddd;
    }
    button {
      margin: 10px 5px;
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      background-color: #6C63FF;
      color: white;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #574bdb;
    }
    .loader {
      border: 6px solid #f3f3f3;
      border-top: 6px solid #6C63FF;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1.5s linear infinite;
      margin: 20px auto;
    }
    .hidden { display: none; }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Modal styling */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none; /* hidden by default */
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .modal-overlay.show {
      display: flex;
    }
    .modal-content {
      background: #ffffff;
      padding: 20px;
      border-radius: 8px;
      text-align: left;
      width: 300px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
    }
    .modal-content h3 {
      margin-top: 0;
    }
    .modal-content input[type="password"] {
      width: 100%;
      padding: 8px;
      margin-bottom: 12px;
      box-sizing: border-box;
    }
    .modal-buttons {
      text-align: right;
    }
    .modal-buttons button {
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>CryptoImage</h2>
    <label for="file"><small>File to encrypt</small></label>
    <input name="file" type="file" id="fileInput">
    <label for="image"><small>(Optional custom image)</small></label>
    <input name="image" type="file" id="coverImageInput" accept="image/*">
    <button onclick="encryptFile()">üîê Encrypt</button>
    <button onclick="decryptImage()">üîì Decrypt</button>
    <canvas id="canvas" class="hidden"></canvas>
    <div id="loader" class="loader hidden"></div>
  </div>

  <!-- Password Modal -->
  <div id="passwordModal" class="modal-overlay">
    <div class="modal-content">
      <h3 id="modalTitle"></h3>
      <input type="password" id="modalPassword" placeholder="Enter password...">
      <div class="modal-buttons">
        <button id="cancelBtn">Cancel</button>
        <button id="okBtn">OK</button>
      </div>
    </div>
  </div>

<script>
//--------------------------------
//  Common Helpers
//--------------------------------
function bufToBase64(buf) {
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
function base64ToBuf(b64) {
  return Uint8Array.from(atob(b64), c => c.charCodeAt(0));
}
function showLoader(show) {
  document.getElementById("loader").classList.toggle("hidden", !show);
}

/**
 * Opens a modal with a given title/message and returns a Promise
 * that resolves with the entered password, or null if cancelled.
 */
function getPasswordFromModal(titleText) {
  return new Promise((resolve) => {
    const modal = document.getElementById('passwordModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalPassword = document.getElementById('modalPassword');
    const okBtn = document.getElementById('okBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    modalTitle.textContent = titleText;
    modalPassword.value = ''; // Reset input
    modal.classList.add('show');

    // Cleanup function to hide modal and remove event listeners
    function closeModal() {
      modal.classList.remove('show');
      okBtn.removeEventListener('click', onOk);
      cancelBtn.removeEventListener('click', onCancel);
    }

    function onOk() {
      const pass = modalPassword.value.trim();
      closeModal();
      resolve(pass || null);
    }

    function onCancel() {
      closeModal();
      resolve(null);
    }

    okBtn.addEventListener('click', onOk);
    cancelBtn.addEventListener('click', onCancel);

    // Optionally focus the password field for quicker typing
    modalPassword.focus();
  });
}

async function deriveAESKey(password, salt) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );
  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 200000, hash: "SHA-512" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}

//--------------------------------
//  Encrypt Function
//--------------------------------
async function encryptFile() {
  const file = document.getElementById("fileInput").files[0];
  if (!file) return alert("Please select a file to encrypt.");

  // Instead of prompt(...), use our password modal:
  const password = await getPasswordFromModal("Password to encrypt:");
  if (!password) {
    return; // user cancelled or empty
  }

  showLoader(true);
  try {
    // 1) Generate and export RSA key pair (encrypted private + public)
    const rsaKeyPair = await crypto.subtle.generateKey(
      { name: "RSA-OAEP", modulusLength: 4096, publicExponent: new Uint8Array([1,0,1]), hash: "SHA-512" },
      true,
      ["encrypt","decrypt"]
    );
    const exportedPriv = await crypto.subtle.exportKey("pkcs8", rsaKeyPair.privateKey);

    // 2) Encrypt the RSA private key with an AES-GCM key derived from the password
    const salt = crypto.getRandomValues(new Uint8Array(32));
    const ivPriv = crypto.getRandomValues(new Uint8Array(12));
    const aesKeyForPriv = await deriveAESKey(password, salt);
    const encryptedPrivKey = await crypto.subtle.encrypt(
      { name:"AES-GCM", iv: ivPriv },
      aesKeyForPriv,
      exportedPriv
    );

    // 3) Encrypt the file + file name with a random AES key
    const fileBuf = await file.arrayBuffer();
    const aesFileKey = crypto.getRandomValues(new Uint8Array(32));

    // 3a) Encrypt the file data
    const ivFile = crypto.getRandomValues(new Uint8Array(12));
    const aesKey = await crypto.subtle.importKey("raw", aesFileKey, "AES-GCM", false, ["encrypt"]);
    const encryptedFile = await crypto.subtle.encrypt(
      { name:"AES-GCM", iv: ivFile },
      aesKey,
      fileBuf
    );

    // 3b) Encrypt the file name
    const fileNameBuf = new TextEncoder().encode(file.name);
    const ivName = crypto.getRandomValues(new Uint8Array(12));
    const encryptedFileName = await crypto.subtle.encrypt(
      { name:"AES-GCM", iv: ivName },
      aesKey,
      fileNameBuf
    );

    // 4) Encrypt the AES file key using the RSA public key
    const encryptedAESKey = await crypto.subtle.encrypt(
      { name:"RSA-OAEP" },
      rsaKeyPair.publicKey,
      aesFileKey
    );

    // 5) Build metadata + concatenate
    const meta = JSON.stringify({
      dataLength: encryptedFile.byteLength,
      encryptedFileName: bufToBase64(encryptedFileName),
      ivName: bufToBase64(ivName),
      encryptedPrivKey: bufToBase64(encryptedPrivKey),
      salt: bufToBase64(salt),
      ivPriv: bufToBase64(ivPriv),
      encryptedAESKey: bufToBase64(encryptedAESKey),
      ivFile: bufToBase64(ivFile)
    });
    const metaBuf = new TextEncoder().encode(meta);

    // 6) Combine meta + encrypted data
    const fullData = new Uint8Array(metaBuf.length + 1 + encryptedFile.byteLength);
    fullData.set(metaBuf);
    fullData[metaBuf.length] = 0x0A; // Separator (LF)
    fullData.set(new Uint8Array(encryptedFile), metaBuf.length + 1);

    //------------------------------------
    // 7) Draw an image into the canvas
    //    If coverImageInput is defined,
    //    use it as the base image.
    //------------------------------------
    const coverFile = document.getElementById("coverImageInput").files[0];

    const embedDataInCanvas = (baseImg) => {
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
    
      // If no image, create a blank white canvas.
      if (!baseImg) {
        const size = 512; // default blank size
        canvas.width = canvas.height = size;
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(0, 0, size, size);
      } else {
        canvas.width = baseImg.width;
        canvas.height = baseImg.height;
        ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);
      }
    
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
    
      // Embed payload size as header (4 bytes)
      const header = new Uint8Array(4);
      header[0] = (fullData.length >>> 24) & 0xFF;
      header[1] = (fullData.length >>> 16) & 0xFF;
      header[2] = (fullData.length >>> 8) & 0xFF;
      header[3] = fullData.length & 0xFF;
    
      // Combine header and data
      const payload = new Uint8Array(4 + fullData.length);
      payload.set(header, 0);
      payload.set(fullData, 4);
    
      const totalBits = payload.length * 8;
      if (totalBits > (data.length / 4) * 3) {
        alert("Image is too small to hold data. Please choose a larger image.");
        showLoader(false);
        return;
      }
    
      let bitIdx = 0;
      for (let i = 0; i < data.length && bitIdx < totalBits; i += 4) {
        for (let ch = 0; ch < 3 && bitIdx < totalBits; ch++) { // R,G,B
          const byteIdx = bitIdx >> 3;
          const bit = 7 - (bitIdx % 8);
          const bitVal = (payload[byteIdx] >> bit) & 1;
          data[i + ch] = (data[i + ch] & 0xFE) | bitVal;
          bitIdx++;
        }
      }
    
      ctx.putImageData(imageData, 0, 0);
      canvas.toBlob((blob) => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "encrypted-image.png";
        document.body.appendChild(a);
        a.click();
        a.remove();
        showLoader(false);
        document.getElementById("fileInput").value = "";
        document.getElementById("coverImageInput").value = "";
      });
    };

    // If there's a cover image, load it first
    if (coverFile) {
      if (!coverFile.type.startsWith("image")) {
        alert("The selected cover file is not an image!");
        showLoader(false);
        return;
      }
      const coverImg = new Image();
      coverImg.onload = () => {
        embedDataInCanvas(coverImg);
      };
      coverImg.src = URL.createObjectURL(coverFile);
    } else {
      // No cover image -> blank canvas
      embedDataInCanvas(null);
    }

  } catch (e) {
    showLoader(false);
    alert("Encryption error: " + e.message);
  }
}

//--------------------------------
//  Decrypt Function
//--------------------------------
async function decryptImage() {
  const file = document.getElementById("fileInput").files[0];
  if (!file || !file.type.startsWith("image")) {
    return alert("Please select a PNG image that contains an encrypted file.");
  }

  // Instead of prompt(...), use our password modal:
  const password = await getPasswordFromModal("Password to decrypt:");
  if (!password) {
    return; // user cancelled or empty
  }

  showLoader(true);

  const img = new Image();

  img.onload = async () => {
    try {
      const canvas = document.getElementById("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  
      // Extract first 32 bits for header
      let bitIdx = 0, pixelIdx = 0;
      const header = new Uint8Array(4);
      for (let byte = 0; byte < 4; byte++) {
        header[byte] = 0;
        for (let b = 0; b < 8; b++) {
          header[byte] = (header[byte] << 1) | (imageData[pixelIdx + (bitIdx % 3)] & 1);
          bitIdx++;
          if (bitIdx % 3 === 0) pixelIdx += 4;
        }
      }
  
      const payloadSize = (header[0]<<24)|(header[1]<<16)|(header[2]<<8)|header[3];
      if (payloadSize <= 0 || payloadSize > (imageData.length / 4) * 3 / 8) {
        throw new Error("Invalid payload size detected.");
      }
  
      // Extract payload
      const payload = new Uint8Array(payloadSize);
      for (let byte = 0; byte < payloadSize; byte++) {
        payload[byte] = 0;
        for (let b = 0; b < 8; b++) {
          payload[byte] = (payload[byte] << 1) | (imageData[pixelIdx + (bitIdx % 3)] & 1);
          bitIdx++;
          if (bitIdx % 3 === 0) pixelIdx += 4;
        }
      }
  
      // Continue existing logic from here:
      const separator = payload.indexOf(0x0A);
      if (separator === -1) throw new Error("Invalid data format.");
  
      const metaBuf = payload.slice(0, separator);
      const meta = JSON.parse(new TextDecoder().decode(metaBuf));
      const encrypted = payload.slice(separator + 1, separator + 1 + meta.dataLength);
  
      // Existing decryption logic unchanged from here
      const salt = base64ToBuf(meta.salt);
      const ivPriv = base64ToBuf(meta.ivPriv);
      const encryptedPriv = base64ToBuf(meta.encryptedPrivKey);
      const decryptedKey = await deriveAESKey(password, salt);
      const privKeyBuf = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: ivPriv },
        decryptedKey,
        encryptedPriv
      );
      const privateKey = await crypto.subtle.importKey(
        "pkcs8",
        privKeyBuf,
        { name: "RSA-OAEP", hash: "SHA-512" },
        false,
        ["decrypt"]
      );
  
      const aesKeyBuf = await crypto.subtle.decrypt(
        { name: "RSA-OAEP" },
        privateKey,
        base64ToBuf(meta.encryptedAESKey)
      );
      const aesKey = await crypto.subtle.importKey("raw", aesKeyBuf, "AES-GCM", false, ["decrypt"]);
  
      const decryptedFile = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: base64ToBuf(meta.ivFile) },
        aesKey,
        encrypted
      );
  
      const decryptedFileNameBuf = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: base64ToBuf(meta.ivName) },
        aesKey,
        base64ToBuf(meta.encryptedFileName)
      );
      const realFileName = new TextDecoder().decode(decryptedFileNameBuf);
  
      const blob = new Blob([decryptedFile]);
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = realFileName || "decrypted_file";
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (e) {
      alert("Error decrypting the image: " + e.message);
    } finally {
      showLoader(false);
    }
  };
  img.src = URL.createObjectURL(file);
}
</script>
</body>
</html>
